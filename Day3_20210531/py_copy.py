# -*- coding:utf8 -*- #
# -----------------------------------------------------------------------------------
# ProjectName:   python_29
# FileName:     py_copy
# Author:      TianChangJun
# Datetime:    2021/6/1 0:43
# Description：深拷贝与浅拷贝的区别
# -----------------------------------

import copy

a = [1, 2, 3, 4, 5, ['a', 'b']]  # 原始对象
b = a  # 赋值，传对象的引用
c = copy.copy(a)  # 对象拷贝，浅拷贝
d = copy.deepcopy(a)  # 对象拷贝，深拷贝
print("a=", a, "   id(a)=", id(a), "id(a[5])=", id(a[5]))
print("b=", b, "   id(b)=", id(b), "id(b[5])=", id(b[5]))
print("c=", c, "   id(c)=", id(c), "id(c[5])=", id(c[5]))
print("d=", d, "   id(d)=", id(d), "id(d[5])=", id(d[5]))
print("*" * 70)
a.append(6)  # 修改对象a
a[5].append('c')  # 修改对象a中的['a','b']数组对象
print("a=", a, "   id(a)=", id(a), "id(a[5])=", id(a[5]))
print("b=", b, "   id(b)=", id(b), "id(b[5])=", id(b[5]))
print("c=", c, "      id(c)=", id(c), "id(c[5])=", id(c[5]))
print("d=", d, "           id(d)=", id(d), "id(d[5])=", id(d[5]))

"""
在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的
但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，
也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），
对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，
而是和原对象里的可变元素指向同一个地址，
所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，
但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。
"""

# 浅拷贝对象中的可变元素(列表，字典，集合)会随着原始数据的改变而改变
# 深拷贝不会随着原始数据的改变而改变

